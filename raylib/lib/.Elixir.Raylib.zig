// this code is autogenerated, do not check it into to your code repository

// ref lib/raylib.ex:14
const std = @import("std");

const ray = @cImport({
    @cInclude("raylib.h");
});

const beam = @import("beam");
const e = @import("erl_nif");

const State = struct { sounds: std.AutoHashMap(u32, ray.Sound) };

// Module callbacks

pub fn load_fn(private: ?*?*anyopaque, _: u32) !void {
    const stored_pointer = try beam.allocator.create(State);
    stored_pointer.* = .{ .sounds = std.AutoHashMap(u32, ray.Sound).init(beam.allocator) };
    private.?.* = stored_pointer;
}

pub fn unload_fn(private: ?*anyopaque) void {
    const priv_ptr_state: *State = @ptrCast(@alignCast(private.?));

    ray.CloseAudioDevice();
    var sound_it = priv_ptr_state.*.sounds.iterator();
    while (sound_it.next()) |entry| {
        ray.UnloadSound(entry.value_ptr.*);
    }
}

// Raylib

pub fn init_window(width: i32, height: i32, title: beam.term) !beam.term {
    const ctitle = try ray_string(title);
    defer beam.allocator.free(ctitle[0..std.mem.len(ctitle)]);
    ray.SetConfigFlags(ray.FLAG_MSAA_4X_HINT);
    ray.InitWindow(width, height, ctitle);

    return beam.make(.ok, .{});
}

pub fn init_audio_device() beam.term {
    ray.InitAudioDevice();
    return beam.make(.ok, .{});
}

pub fn set_target_fps(fps: i32) beam.term {
    ray.SetTargetFPS(fps);
    return beam.make(.ok, .{});
}

pub fn window_should_close() bool {
    return ray.WindowShouldClose();
}

pub fn load_sound(sound_id: u32, sound_path: beam.term) !beam.term {
    const zsound_path = try ray_string(sound_path);
    const sound = ray.LoadSound(zsound_path);
    if (ray.IsSoundValid(sound)) {
        try get_priv_state().*.sounds.put(sound_id, sound);
        return beam.make(.ok, .{});
    } else {
        return beam.make(.{ .@"error", .invalid }, .{});
    }
}

const ColorType = enum { lightgray, raywhite, lime };

fn cast_color(icolor: beam.term) !ray.Color {
    const zcolor = try beam.get(ColorType, icolor, .{});
    return switch (zcolor) {
        .lightgray => ray.LIGHTGRAY,
        .raywhite => ray.RAYWHITE,
        .lime => ray.LIME,
    };
}

// hack: [*c]const u8 in signature is not working
fn ray_string(text: beam.term) ![*c]const u8 {
    const text_slice = try beam.get([]const u8, text, .{});
    const null_terminated = try beam.allocator.alloc(u8, text_slice.len + 1);
    @memcpy(null_terminated[0..text_slice.len], text_slice);
    null_terminated[text_slice.len] = 0;
    return null_terminated.ptr;
}

const LogLevelType = enum { log_debug, log_info, log_error };

pub fn set_trace_log_level(ilog_level: beam.term) !beam.term {
    const zlevel = try beam.get(LogLevelType, ilog_level, .{});
    const level = switch (zlevel) {
        .log_info => ray.LOG_INFO,
        .log_debug => ray.LOG_DEBUG,
        .log_error => ray.LOG_ERROR,
    };

    ray.SetTraceLogLevel(level);

    return beam.make(.ok, .{});
}

pub fn close_window() beam.term {
    ray.CloseWindow();
    return beam.make(.ok, .{});
}

const Vector2 = struct { x: f32, y: f32 };
const OperationType = enum { begin_drawing, end_drawing, draw_text, draw_fps, draw_circle, draw_circle_v, play_sound, clear_background };
const Operation = struct { op: OperationType, args: beam.term };
const DrawTextArguments = struct { text: beam.term, x: i32, y: i32, font_size: i32, color: beam.term };
const DrawFPSArguments = struct { x: i32, y: i32 };
const DrawCircleArguments = struct { x: i32, y: i32, radius: f32, color: beam.term };
const DrawCircleVArguments = struct { center: Vector2, radius: f32, color: beam.term };
const PlaySoundArguments = struct { sound_id: u32 };
const ClearBackgroundArguments = struct { color: beam.term };

pub fn execute(ops: []Operation) !beam.term {
    ray.BeginDrawing();

    for (ops) |op| {
        switch (op.op) {
            .begin_drawing => ray.BeginDrawing(),
            .end_drawing => ray.EndDrawing(),
            .draw_circle_v => {
                const args = try beam.get(DrawCircleVArguments, op.args, .{});
                ray.DrawCircleV(ray.Vector2{ .x = args.center.x, .y = args.center.y }, args.radius, try cast_color(args.color));
            },
            .draw_circle => {
                const args = try beam.get(DrawCircleArguments, op.args, .{});
                ray.DrawCircle(args.x, args.y, args.radius, try cast_color(args.color));
            },
            .draw_text => {
                const args = try beam.get(DrawTextArguments, op.args, .{});
                const ctext = try ray_string(args.text);
                defer beam.allocator.free(ctext[0..std.mem.len(ctext)]);

                ray.DrawText(ctext, args.x, args.y, args.font_size, try cast_color(args.color));
            },
            .draw_fps => {
                const args = try beam.get(DrawFPSArguments, op.args, .{});
                ray.DrawFPS(args.x, args.y);
            },
            .play_sound => {
                const args = try beam.get(PlaySoundArguments, op.args, .{});
                const sound = get_priv_state().*.sounds.get(args.sound_id) orelse unreachable;
                ray.PlaySound(sound);
            },
            .clear_background => {
                const args = try beam.get(ClearBackgroundArguments, op.args, .{});
                ray.ClearBackground(try cast_color(args.color));
            },
        }
    }
    ray.EndDrawing();
    return beam.make(.ok, .{});
}

fn get_priv_state() *State {
    const priv_ptr: ?*anyopaque = e.enif_priv_data(beam.context.env);
    const priv_ptr_state: *State = @ptrCast(@alignCast(priv_ptr.?));
    return priv_ptr_state;
}
